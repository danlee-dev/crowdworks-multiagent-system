import uuid
import json
from datetime import datetime
from typing import Dict, Optional, List, Any
from ..database import ChatDatabase
from .models.models import StreamingAgentState


class RunManager:
    """Ïä§Ìä∏Î¶¨Î∞ç Ïã§Ìñâ ÏÉùÎ™ÖÏ£ºÍ∏∞ Í¥ÄÎ¶¨ Î∞è runId Ï∂îÏ†Å"""

    def __init__(self, db: ChatDatabase, websocket_manager=None):
        self.db = db
        self.websocket_manager = websocket_manager
        self.active_runs: Dict[str, StreamingAgentState] = {}

    def create_run(self, conversation_id: str, query: str, flow_type: str = "chat") -> str:
        """ÏÉà Ïã§Ìñâ ÏÉùÏÑ± Î∞è runId Î∞òÌôò"""
        run_id = f"run_{uuid.uuid4().hex[:12]}"
        current_time = datetime.now().isoformat()

        # Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÉùÏÑ±
        initial_state: StreamingAgentState = {
            "original_query": query,
            "conversation_id": conversation_id,
            "user_id": "default_user",  # TODO: Ïã§Ï†ú ÏÇ¨Ïö©Ïûê IDÎ°ú Î≥ÄÍ≤Ω
            "start_time": current_time,
            "flow_type": flow_type,
            "plan": None,
            "current_step_index": 0,
            "step_results": [],
            "execution_log": [],
            "needs_replan": False,
            "replan_feedback": None,
            "final_answer": None,
            "session_id": conversation_id,
            "metadata": {
                "run_id": run_id,
                "status": "running",
                "created_at": current_time
            }
        }

        # Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû•
        self.active_runs[run_id] = initial_state

        # DBÏóê Ïã§Ìñâ Ïª®ÌÖçÏä§Ìä∏ Ï†ÄÏû•
        self._save_execution_context(run_id, initial_state)

        # WebSocketÏóê runId Îß§Ìïë Îì±Î°ù
        if self.websocket_manager:
            self.websocket_manager.register_run(run_id, conversation_id)

        print(f"üöÄ ÏÉà Ïã§Ìñâ ÏÉùÏÑ±: {run_id} (ÎåÄÌôî: {conversation_id})")
        return run_id

    def get_run_state(self, run_id: str) -> Optional[StreamingAgentState]:
        """runIdÎ°ú ÌòÑÏû¨ ÏÉÅÌÉú Ï°∞Ìöå (Î©îÎ™®Î¶¨ Ïö∞ÏÑ†, DB Ìè¥Î∞±)"""

        # 1. Î©îÎ™®Î¶¨ÏóêÏÑú Î®ºÏ†Ä Ï∞æÍ∏∞
        if run_id in self.active_runs:
            return self.active_runs[run_id]

        # 2. DBÏóêÏÑú Î≥µÍµ¨ ÏãúÎèÑ
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT * FROM execution_contexts WHERE run_id = ?
                """, (run_id,))

                row = cursor.fetchone()
                if row:
                    context = dict(row)
                    if context["current_state"]:
                        state = json.loads(context["current_state"])
                        self.active_runs[run_id] = state  # Î©îÎ™®Î¶¨Ïóê Îã§Ïãú Î°úÎìú
                        print(f"üîÑ Ïã§Ìñâ ÏÉÅÌÉú DBÏóêÏÑú Î≥µÍµ¨: {run_id}")
                        return state

        except Exception as e:
            print(f"‚ö†Ô∏è Ïã§Ìñâ ÏÉÅÌÉú Î≥µÍµ¨ Ïã§Ìå® ({run_id}): {e}")

        return None

    def update_run_state(self, run_id: str, updates: Dict[str, Any]) -> bool:
        """Ïã§Ìñâ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        if run_id not in self.active_runs:
            print(f"‚ö†Ô∏è Ïã§ÌñâÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå: {run_id}")
            return False

        # Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
        state = self.active_runs[run_id]
        for key, value in updates.items():
            if key in state:
                state[key] = value
            elif key in state.get("metadata", {}):
                state["metadata"][key] = value

        # DB ÏóÖÎç∞Ïù¥Ìä∏
        self._save_execution_context(run_id, state)

        return True

    def save_checkpoint(self, run_id: str, checkpoint_type: str, data: Dict[str, Any], step_number: Optional[int] = None):
        """Ï§ëÍ∞Ñ Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•"""
        print(f"üìç Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû• ÏãúÎèÑ: run_id={run_id}, type={checkpoint_type}, data_keys={list(data.keys())}")

        state = self.get_run_state(run_id)
        if not state:
            print(f"‚ö†Ô∏è Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû• Ïã§Ìå® - Ïã§Ìñâ ÏóÜÏùå: {run_id}")
            return

        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO streaming_checkpoints (
                        run_id, conversation_id, checkpoint_type,
                        checkpoint_data, step_number
                    ) VALUES (?, ?, ?, ?, ?)
                """, (
                    run_id,
                    state["conversation_id"],
                    checkpoint_type,
                    json.dumps(data),
                    step_number
                ))

            print(f"üìç Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû•: {run_id} - {checkpoint_type}")

        except Exception as e:
            print(f"‚ö†Ô∏è Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï†ÄÏû• Ïò§Î•ò: {e}")

    def request_abort(self, run_id: str, reason: str = "user_requested") -> bool:
        """Ï§ëÎã® ÏöîÏ≤≠"""
        state = self.get_run_state(run_id)
        if not state:
            print(f"‚ö†Ô∏è Ï§ëÎã® ÏöîÏ≤≠ Ïã§Ìå® - Ïã§Ìñâ ÏóÜÏùå: {run_id}")
            return False

        # ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        self.update_run_state(run_id, {
            "metadata": {
                **state.get("metadata", {}),
                "status": "aborted",
                "abort_reason": reason,
                "abort_time": datetime.now().isoformat()
            }
        })

        # Ïä§Ìä∏Î¶¨Î∞ç ÏÑ∏ÏÖòÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    UPDATE streaming_sessions
                    SET abort_requested = 1, status = 'aborted'
                    WHERE run_id = ?
                """, (run_id,))

        except Exception as e:
            print(f"‚ö†Ô∏è Ïä§Ìä∏Î¶¨Î∞ç ÏÑ∏ÏÖò Ï§ëÎã® ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")

        # WebSocketÏúºÎ°ú Ï§ëÎã® ÏïåÎ¶º Ï†ÑÏÜ°
        if self.websocket_manager:
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                loop.create_task(
                    self.websocket_manager.broadcast_abort_notification(run_id, reason)
                )
            except Exception as e:
                print(f"‚ö†Ô∏è WebSocket Ï§ëÎã® ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®: {e}")

        print(f"üõë Ïã§Ìñâ Ï§ëÎã® ÏöîÏ≤≠: {run_id} (ÏÇ¨Ïú†: {reason})")
        return True

    def is_abort_requested(self, run_id: str) -> bool:
        """Ï§ëÎã®Ïù¥ ÏöîÏ≤≠ÎêòÏóàÎäîÏßÄ ÌôïÏù∏"""
        state = self.get_run_state(run_id)
        if not state:
            return False

        status = state.get("metadata", {}).get("status")
        return status == "aborted"

    def mark_completed(self, run_id: str, final_answer: str) -> bool:
        """Ïã§Ìñâ ÏôÑÎ£å Ï≤òÎ¶¨"""
        return self.update_run_state(run_id, {
            "final_answer": final_answer,
            "metadata": {
                "status": "completed",
                "completed_at": datetime.now().isoformat()
            }
        })

    def mark_error(self, run_id: str, error_message: str) -> bool:
        """Ïã§Ìñâ Ïò§Î•ò Ï≤òÎ¶¨"""
        return self.update_run_state(run_id, {
            "metadata": {
                "status": "error",
                "error_message": error_message,
                "error_at": datetime.now().isoformat()
            }
        })

    def cleanup_run(self, run_id: str):
        """Ïã§Ìñâ ÏôÑÎ£å/Ï§ëÎã® ÌõÑ Ï†ïÎ¶¨"""
        # WebSocket Îß§Ìïë Ìï¥Ï†ú
        if self.websocket_manager:
            self.websocket_manager.unregister_run(run_id)

        # Î©îÎ™®Î¶¨ÏóêÏÑú Ï†úÍ±∞ (DBÎäî Ïú†ÏßÄ)
        if run_id in self.active_runs:
            del self.active_runs[run_id]
            print(f"üßπ Ïã§Ìñâ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨: {run_id}")

    def find_active_run(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """ÎåÄÌôîÏóêÏÑú ÏßÑÌñâ Ï§ëÏù∏ Ïã§Ìñâ Ï∞æÍ∏∞"""
        try:
            print(f"üîç find_active_run Ìò∏Ï∂ú: conversation_id={conversation_id}")

            with self.db.get_connection() as conn:
                cursor = conn.cursor()

                # Î®ºÏ†Ä Ìï¥Îãπ ÎåÄÌôîÏùò Î™®Îì† Ïã§Ìñâ Ï°∞Ìöå
                cursor.execute("""
                    SELECT run_id, status, created_at FROM execution_contexts
                    WHERE conversation_id = ?
                    ORDER BY created_at DESC
                """, (conversation_id,))

                all_runs = cursor.fetchall()
                print(f"üìä ÎåÄÌôî {conversation_id}Ïùò Î™®Îì† Ïã§Ìñâ: {[dict(row) for row in all_runs]}")

                # running ÏÉÅÌÉúÏù∏ Ïã§Ìñâ Ï∞æÍ∏∞
                cursor.execute("""
                    SELECT * FROM execution_contexts
                    WHERE conversation_id = ? AND status = 'running'
                    ORDER BY created_at DESC LIMIT 1
                """, (conversation_id,))

                row = cursor.fetchone()
                if row:
                    result = dict(row)
                    # print(f"‚úÖ ÌôúÏÑ± Ïã§Ìñâ Î∞úÍ≤¨: {result}")
                    return result
                else:
                    print(f"‚ùå ÌôúÏÑ± Ïã§Ìñâ ÏóÜÏùå")

        except Exception as e:
            print(f"‚ö†Ô∏è ÌôúÏÑ± Ïã§Ìñâ Ï°∞Ìöå Ïò§Î•ò: {e}")

        return None

    def get_checkpoints(self, run_id: str, checkpoint_type: Optional[str] = None) -> List[Dict[str, Any]]:
        """Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()

                if checkpoint_type:
                    cursor.execute("""
                        SELECT * FROM streaming_checkpoints
                        WHERE run_id = ? AND checkpoint_type = ?
                        ORDER BY timestamp ASC
                    """, (run_id, checkpoint_type))
                else:
                    cursor.execute("""
                        SELECT * FROM streaming_checkpoints
                        WHERE run_id = ?
                        ORDER BY timestamp ASC
                    """, (run_id,))

                checkpoints = []
                for row in cursor.fetchall():
                    checkpoint = dict(row)
                    checkpoint["checkpoint_data"] = json.loads(checkpoint["checkpoint_data"])
                    checkpoints.append(checkpoint)

                return checkpoints

        except Exception as e:
            print(f"‚ö†Ô∏è Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return []

    def _save_execution_context(self, run_id: str, state: StreamingAgentState):
        """Ïã§Ìñâ Ïª®ÌÖçÏä§Ìä∏Î•º DBÏóê Ï†ÄÏû•"""
        try:
            with self.db.get_connection() as conn:
                cursor = conn.cursor()

                cursor.execute("""
                    INSERT OR REPLACE INTO execution_contexts (
                        run_id, conversation_id, original_query, flow_type,
                        plan, current_state, updated_at, status
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    run_id,
                    state["conversation_id"],
                    state["original_query"],
                    state.get("flow_type"),
                    json.dumps(state.get("plan")) if state.get("plan") else None,
                    json.dumps(state),
                    datetime.now().isoformat(),
                    state.get("metadata", {}).get("status", "running")
                ))

        except Exception as e:
            print(f"‚ö†Ô∏è Ïã§Ìñâ Ïª®ÌÖçÏä§Ìä∏ Ï†ÄÏû• Ïò§Î•ò: {e}")


# Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§ (Ïã±Í∏ÄÌÜ§ Ìå®ÌÑ¥)
_run_manager_instance: Optional[RunManager] = None

def get_run_manager(db: ChatDatabase) -> RunManager:
    """RunManager Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    global _run_manager_instance
    if _run_manager_instance is None:
        _run_manager_instance = RunManager(db)
    return _run_manager_instance
